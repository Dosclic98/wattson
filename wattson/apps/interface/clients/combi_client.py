import logging
import queue
import threading as th
import time
from typing import Optional, Union, Tuple, Any, Dict, Callable

from wattson.apps.interface.util.messages import MtuCacheReply
from wattson.apps.interface.util.status_logger import StatusLogger
from wattson.util import get_logger, ContextLogger, log_contexts

from wattson.apps.interface.clients.receive_worker import ReceiveWorker
from wattson.apps.interface.clients.publisher_client import PublisherClient
from wattson.apps.interface.clients.reference_type import ReferenceType
from wattson.apps.interface.clients import CommandClient

from wattson.apps.interface.util.constants import *
from wattson.apps.interface.util import ConfirmationStatus, FailReason
from wattson.apps.interface.util import messages as msgs

from wattson.iec104.interface.types import TypeID
from wattson.iec104.common import ConnectionState


class CombiClient(th.Thread):
    """
    Implements the Comand & Subscription client, as well as combining
    them with local caching, filtering, and callback functionality.
    Each incoming msg from the publishing client is divided into one of four categories:
        1. Update on a previously send command from this client(/app implementing it)
        2. Update on a command of a different client/app
        3. Re-packed/updated IEC-msg generated by an MTU/RTU independently of interface
        4. Dp-update, independent of what caused it

    For an incoming msg the client will go the following route:
        - If it is an update to a locally send cmd, check if a special_callback
            for this command was set
        - Check if a callback for the class of the incoming msg was set
        - check if storing the msg is allowed
        - check for a general callback
        - throwaway msg

    By default, storing of for classes: 1, 3, and 4 is enabled
    If no callback for any of these is set, the corresponding queues will have to be read
        by the application. They are set to have unlimited size if not overwritten by kwargs!

    For the callbacks, the first argument will always be the msg published by the server.
    If this is a reply to a command send through this client, the original command is
        added as second argument.

    Since the prior handling requires storing previously send commands and
        needing to access them for an unknown number of times, every x minutes,
        those cmds stored for my than y seconds will be automatically removed.
    """
    class SendMsgEntry:
        def __init__(self, msg: msgs.IECMsg):
            self.msg = msg
            self.insert_ts = time.time()

        def too_old(self, max_storage_time: float, clean_ts: float = 0.0):
            clean_ts = time.time() if clean_ts == 0 else clean_ts
            return self.insert_ts < clean_ts - max_storage_time

        def __str__(self):
            return str(self.msg)

    def __init__(self, node_id: str, logger: Optional[logging.Logger] = None, **kwargs):
        """
        Args:
            node_id: host's node ID
            logger: parent-logger
            **kwargs:
                Storage decisions:
                    (stores msg if this is True and resp. callback not set)
                    - store_dp_update: bool (True)
                    - store_cmd_reply: bool (False)
                    - store_cmd_update: bool  (True)
                    - store_external_update: bool (False)
                    - store_mtu_update: bool (True)

                Storage params:
                    - storage_time: int (360) seconds
                    - maxsize: int (0 = infinite)
                    - clean_after_x_minutes: int (5)    <- actually sort of duplicates storage_time and could be removed

                Callbacks:
                    - on_cmd_reply: Reply to cmd send by this application
                    - on_dp_update: Any dp-containing msg
                    - on_cmd_update: Non-initial-reply Update to previously send cmd
                    - on_external_update: different app's cmd reply
                    - on_mtu_update:    any general msg initiated by the MTU/RTU
                    - on_update:    every msg except datapoint-containing ones (if no special one set for this msg)

                Conn-setup:
                    mtu_ip: Server-side IP (assumes cmd & pub-servers are on same IP)
                    mtu_cmd_port: Command Server's port (default set)
                    mtu_sub_port: Pub-Sub Server's port (default set)

                Others:
                    reject_pre_interro_commands: bool (False): Ignore all inc. msgs before interrogation was performed
                    log_name: str (Combi_Client_{node_id})
                    active_contexts: Iterable (active logging contexts)
                    pub_worker_cnt: #ZMQ-Workers to handle incoming msgs from Pub-server
        """
        super().__init__()
        # if on_x is not set as callback and store_x == True
        #   -> stores corresponding message in the queue self.queue['x']

        # Meaning of the keys:
        # cmd_reply: Reply to a any message (not strictly IEC104) requested by this client, usually a confirmation msg
        # dp_update: Any datapoint-containing message
        # on_external_update: as cmd_reply but requested by a different client
        # on_mtu_update: any general message except for dp-updates send by the MTU/RTU
        #                - not initiated by any outside client
        # on_update: every msg except datapoint-containing ones
        callbacks: Dict[str, Optional[Callable]] = {
            "on_cmd_reply": None,
            "on_update": None,
            "on_dp_update": None,
            "on_cmd_update": None,
            "on_external_update": None,
            "on_mtu_update": None,
        }
        store_opts = {
            "store_dp_update": True,
            "store_cmd_reply": False,
            "store_cmd_update": True,
            "store_external_update": False,
            "store_mtu_update": True,
            "storage_time": 360,         # seconds
            "maxsize": 0,                # 0 = infinite
            "clean_after_x_minutes": 5,
        }
        callbacks.update({k_v for k_v in kwargs.items() if k_v[0] in callbacks})
        store_opts.update({k_v for k_v in kwargs.items() if k_v[0] in store_opts})
        self.callbacks = callbacks
        self.store_opts = store_opts
        self._last_clean = 0
        self._send_msgs: Dict[str, CombiClient.SendMsgEntry] = {}

        self._special_msg_callback = {}
        self.reject_pre_interro_commands = kwargs.get('reject_pre_interro_commands', False)

        self._interro_status = {}
        self._interro_ref_nrs = {}
        self._queued_pre_interro_commands = {}

        self.node_id = node_id

        log_name = kwargs.get('log_name', f"Combi_Client_{node_id}")
        if logger is not None:
            self.logger = logger.getChild(log_name)
        else:
            self.logger = get_logger(
                self.node_id, f"Wattson.{log_name}", active_contexts=kwargs.get('active_contexts')
            )
        self.logger.setLevel(logging.INFO)

        self.mtu_ip = kwargs.get('mtu_ip', DEFAULT_PUB_SERVER_IP)
        self.cmd_port = kwargs.get('mtu_cmd_port', DEFAULT_CMD_SERVER_PORT)
        self.sub_port = kwargs.get('mtu_sub_port', DEFAULT_PUB_SERVER_PORT)

        self.connected = th.Event()
        self._terminate = th.Event()
        self.running = th.Event()

        self.status_logger = StatusLogger()

        self.ref_lock = th.Lock()
        self.reference_prefix = ""
        self._reference_cnt = 0
        self.cmd_client = CommandClient(self.mtu_ip, self.cmd_port, node_id=self.node_id,
                                        logger=self.logger, log_name="CmdClient",
                                        status_logger=self.status_logger.get_child("command-client"),
                                        connected=self.connected)
        self.pub_client = PublisherClient(self.mtu_ip, self.sub_port, logger=self.logger,
                                          log_name="PubClient", node_id=self.node_id,
                                          status_logger=self.status_logger.get_child("publisher-client"))
        self.cmd_client.logger.setLevel(logging.INFO)
        self.pub_client.logger.setLevel(logging.INFO)
        self.queues = {}

        self._workers = []
        self._worker_count = kwargs.get('pub_worker_cnt', 10)

        for key in ("cmd_reply", "cmd_update", "mtu_update", "external_update", "dp_update"):
            enable_queue = self.store_opts[f"store_{key}"]
            self.queues[key] = queue.Queue(self.store_opts["maxsize"]) if enable_queue else None

    def start(self):
        self.logger.info("Starting Combi Subscription Client")
        self.cmd_client.start()
        self.pub_client.start()
        self.reference_prefix = self.cmd_client.subscriber_prefix
        self._last_clean = time.time()

        for _ in range(self._worker_count):
            worker = ReceiveWorker(self.pub_client.read_messages, self._on_update)
            self._workers.append(worker)
            worker.start()

        super().start()
        self.running.set()

    def run(self):
        """
        Periodically cleans storage, nothing else necessary
        """
        while not self._terminate.is_set():
            if time.time() < self._last_clean - self.store_opts["clean_after_x_minutes"] * 60:
                self.clean_storage()
            time.sleep(2)

        self.cmd_client.stop()
        self.pub_client.stop()

        for worker in self._workers:
            worker.stop()

    def stop(self):
        self._terminate.set()

    def _on_cmd_reply(self, reply: msgs.Confirmation, orig_msg: msgs.IECMsg) -> Any:
        if self.callbacks["on_cmd_reply"] is not None:
            return self.callbacks["on_cmd_reply"](reply, orig_msg)

    def _on_update(self, update: msgs.IECMsg) -> Any:
        if not self.reject_pre_interro_commands:
            self._handle_internal_update(update)

        if update.reference_nr.startswith(self.node_id):
            self.logger.debug(f"{update}")

        if update.reference_nr in self._special_msg_callback:
            cb = self._special_msg_callback.pop(update.reference_nr)
            orig_msg = self._send_msgs[update.reference_nr]
            stop_propagation = cb(update, orig_msg)
            if stop_propagation:
                return

        callback, _args, ref_type = self._decide_special_callback_and_args_for_update(update)
        if callback:
            return callback(*_args)
        elif self.callbacks["on_update"] and ref_type != ReferenceType.DPUpdate:
            return self.callbacks["on_update"](update, ref_type)
        else:
            self.logger.warning("NO callback set for this update")

    def _handle_internal_update(self, update: msgs.IECMsg):
        if isinstance(update, msgs.SysInfoControl) and update.type_ID == TypeID.C_IC_NA_1:
            self._interro_ref_nrs[update.reference_nr] = update.coa
        elif (
                isinstance(update, msgs.Confirmation)
                and update.reference_nr in self._interro_ref_nrs
                and update.result['status'] == ConfirmationStatus.SUCCESSFUL_TERM.value
        ):
            coa = self._interro_ref_nrs.pop(update.reference_nr)
            self._interro_status[coa] = ConnectionState.INTERRO_DONE
            self._send_pre_interro_commands_if_exists(coa)

    def _send_pre_interro_commands_if_exists(self, coa: int):
        if coa in self._queued_pre_interro_commands:
            while self._queued_pre_interro_commands[coa]:
                cmd = self._queued_pre_interro_commands[coa].pop()
                self.cmd_client.send_msg(cmd)

    def _decide_special_callback_and_args_for_update(self, update: msgs.IECMsg) -> Tuple[
                                                    Optional[Callable], Tuple, ReferenceType]:
        """
        Decides which callback to call and with which arguments

        Args:
            update: incoming msg

        Returns:
            Callback, args for cb, Type of update
        """
        callback = None
        call_args = [update]
        if isinstance(update, msgs.ProcessInfoMonitoring):
            ref_type = ReferenceType.DPUpdate
            if self.callbacks["on_dp_update"] is not None:
                if self.msg_from_subscriber(update):
                    call_args.append(self._send_msgs[update.reference_nr].msg)
                    callback = self._on_C_RD_dp_update
                else:
                    callback = self.callbacks["on_dp_update"]

            elif self.store_opts["store_dp_update"]:
                callback = self._store_update

        elif update.reference_nr.startswith("MTU"):
            ref_type = ReferenceType.MTUUpdate
            if self.callbacks["on_mtu_update"] is not None:
                callback = self.callbacks["on_mtu_update"]
            elif self.store_opts["store_mtu_update"]:
                callback = self._store_update

        elif self.msg_from_subscriber(update):
            ref_type = ReferenceType.CmdUpdate
            if self.callbacks["on_cmd_update"] is not None:
                callback = self.callbacks["on_cmd_update"]
                call_args.append(self._send_msgs[update.reference_nr].msg)
            elif self.store_opts["store_cmd_update"]:
                callback = self._store_update

        else:
            ref_type = ReferenceType.ExternalUpdate
            if self.callbacks["on_external_update"] is not None:
                callback = self.callbacks["on_external_update"]
            elif self.store_opts["store_external_update"]:
                callback = self._store_update

        if callback == self._store_update:
            call_args.append(ref_type)

        return callback, tuple(call_args), ref_type

    def _store_update(self, update: msgs.IECMsg, ref_type: ReferenceType) -> None:
        que = self.queues[ref_type.to_queue_name()]
        if que:
            try:
                que.put(update)
            except queue.Full:
                self.logger.warning(f"Full combi client queue {ref_type.to_queue_name()}.")

    def _on_cmd_update(self, update: msgs.IECMsg) -> Any:
        if self.callbacks["on_cmd_update"] is not None:
            orig_msg = self._send_msgs[update.reference_nr].msg
            return self.callbacks["on_cmd_update"](update, orig_msg)

    def _on_external_update(self, update: msgs.IECMsg) -> Any:
        if self.callbacks["on_external_update"] is not None:
            return self.callbacks["on_external_update"](update)

    def _on_mtu_update(self, update: msgs.IECMsg) -> Any:
        if self.callbacks["on_mtu_update"] is not None:
            return self.callbacks["on_mtu_update"](update)

    def has_update(self, ref_type: Optional[ReferenceType] = None) -> bool:
        """ Checks if update for this type is stored """
        if ref_type:
            return not self.queues[ref_type.to_queue_name()].empty()

        for que in self.queues.values():
            if que and not que.empty():
                return True
        return False

    def get_dp_update(self, block: bool = False, timeout: float = 0.0) -> Tuple[
                     Union[msgs.ProcessInfoMonitoring, msgs.PeriodicUpdate],
                     Optional[msgs.ReadDatapoint]]:
        """ Retrieves stored dp-update if exists """
        return self.get_update(ReferenceType.DPUpdate, block, timeout)

    def get_update(self, ref_type: ReferenceType, block: bool = False,
                   timeout: float = 0.0) -> Tuple[msgs.IECMsg, Optional[msgs.IECMsg]]:
        """ Retrieves stored msg of this type if exists """
        old_msg = None
        update_msg = self.queues[ref_type.to_queue_name()].get(block, timeout)
        if ref_type == ReferenceType.CmdUpdate:
            old_msg = self._send_msgs[update_msg.reference_nr].msg
        return update_msg, old_msg

    def send_cmd(self, msg: msgs.IECMsg, special_callback:
                 Optional[Callable[[msgs.IECMsg, msgs.Confirmation], Any]] = None) -> Any:
        if msg.reference_nr == UNSET_REFERENCE_NR:
            msg.reference_nr = self.next_reference_nr
        self._send_msgs[msg.reference_nr] = CombiClient.SendMsgEntry(msg)

        if self.reject_pre_interro_commands and not self.interro_done_for_msg(msg):
            res = msgs.Confirmation(result={
                'status': ConfirmationStatus.FAIL,
                'reason': FailReason.INTERRO_UNFINISHED
            }, reference_nr=msg.reference_nr, max_tries=msg.max_tries)
            return self._on_cmd_reply(res, msg)

        if special_callback is not None:
            if msg.reference_nr in self._special_msg_callback:
                raise ValueError(f"Cannot set callback for already reserved ref. nr.")

            self._special_msg_callback[msg.reference_nr] = special_callback

        if not self.reject_pre_interro_commands or self.interro_done_for_msg(msg):
            res = self.cmd_client.send_msg(msg)
            if res is None:
                res = msgs.Confirmation({
                    'status': ConfirmationStatus.FAIL,
                    'reason': FailReason.SERVER,
                }, msg.reference_nr, msg.max_tries)
        else:
            # must have COA
            if msg.coa in self._queued_pre_interro_commands:
                self._queued_pre_interro_commands[msg.coa].append(msg)
            else:
                self._queued_pre_interro_commands[msg.coa] = [msg]

            res = msgs.Confirmation(result={
                'status': ConfirmationStatus.CLIENT_QUEUED,
                'reason': FailReason.INTERRO_UNFINISHED
            }, reference_nr=msg.reference_nr, max_tries=msg.max_tries)
        return self._on_cmd_reply(res, msg)

    def _on_C_RD_dp_update(self, update: msgs.ProcessInfoMonitoring, read_msg: msgs.ReadDatapoint):
        """ necessary to communicate termination of command """
        self.callbacks['on_dp_update'](update, read_msg)
        final_update = msgs.Confirmation({"status": ConfirmationStatus.FINAL_RESP_RCVD},
                                         update.reference_nr, update.max_tries)
        self._on_cmd_update(final_update)

    def delete_send_msg(self, ref_nr: str):
        if ref_nr in self._send_msgs:
            del self._send_msgs[ref_nr]

    def clean_storage(self):
        to_del = set()
        clean_ts = time.time()
        for key, entry in self._send_msgs.items():
            if entry.too_old(self.store_opts["storage_time"], clean_ts):
                to_del.add(key)
        for key in to_del:
            del self._send_msgs[key]
        self._last_clean = time.time()

    def msg_from_subscriber(self, msg: msgs.IECMsg):
        return msg.reference_nr.startswith(f"{self.reference_prefix}_")

    @property
    def next_reference_nr(self):
        return f"{self.reference_prefix}_{self._next_reference_cnt}"

    @property
    def _next_reference_cnt(self):
        with self.ref_lock:
            self._reference_cnt += 1
            return self._reference_cnt - 1

    def interro_done_for_msg(self, msg: msgs.IECMsg):
        coa = msg.__dict__.get('coa')
        if coa is not None and self._interro_status.get(coa) == ConnectionState.INTERRO_DONE:
            return True
        elif coa is not None:
            return self._check_and_update_interro_status(coa)
        return True

    def get_rtu_status(self) -> dict:
        status = {}
        msg = msgs.RTUStatusReq(self.next_reference_nr)
        res = self.cmd_client.send_msg(msg)
        if res is None:
            self.logger.critical("Cannot update status, timeout")
            return status

        for coa, s in res.status.items():
            status[coa] = s[2]

        return status

    def get_mtu_cache(self) -> dict:
        """
        Requests and returns the local data point value cache of the MTU.
        Returns a dictionary with data point identifiers as keys and a dictionary as value.
        The value dictionary contains the value, the time and the COT of the last data point transmission.
        :return: The MTU's local data point cache
        """
        cache = {}
        msg = msgs.MtuCacheReq(self.next_reference_nr)
        res: Optional[MtuCacheReply] = self.cmd_client.send_msg(msg)
        if res is None:
            self.logger.critical("Cannot load cache, timeout")
            return cache
        cache = res.cache
        return cache

    def _check_and_update_interro_status(self, coa: int) -> bool:
        msg = msgs.RTUStatusReq(self.next_reference_nr)
        res = self.cmd_client.send_msg(msg)
        if res is None:
            self.logger.critical("Cannot update status, timeout")
            return False

        if coa not in res.status:
            raise ValueError("Unknown COA to MTU")
        self._interro_status[coa] = ConnectionState.from_name(res.status[coa][2])
        res = self._interro_status[coa] == ConnectionState.INTERRO_DONE
        return res
